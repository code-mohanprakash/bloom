import Foundation
import PDFKit
import UIKit

// MARK: - Protocol

protocol PDFGeneratorServiceProtocol {
    /// Generates a branded PDF summarising cycle history and daily logs.
    func generateCycleSummaryPDF(cycles: [CycleEntry], logs: [DailyLog]) -> Data

    /// Generates a branded PDF summarising the active pregnancy profile.
    func generatePregnancySummaryPDF(pregnancy: PregnancyProfile) -> Data
}

// MARK: - PDFGeneratorService

/// Renders print-quality PDFs using `UIGraphicsPDFRenderer`.
///
/// Layout conventions:
/// - A4 page size (595 × 842 pts).
/// - 40 pt margins on all sides.
/// - BloomHer brand header with logo text and accent bar.
/// - Alternating row shading in data tables.
/// - Medical disclaimer footer on every page.
/// - "Generated by BloomHer" watermark in the footer area.
final class PDFGeneratorService: PDFGeneratorServiceProtocol {

    // MARK: - Page Geometry

    private let pageWidth:    CGFloat = 595
    private let pageHeight:   CGFloat = 842
    private let marginH:      CGFloat = 40
    private let marginV:      CGFloat = 40
    private var contentWidth: CGFloat { pageWidth - marginH * 2 }

    // MARK: - Colours

    private let brandPink    = UIColor(red: 0.91, green: 0.55, blue: 0.61, alpha: 1) // #E88B9C
    private let brandMint    = UIColor(red: 0.66, green: 0.84, blue: 0.73, alpha: 1) // #A8D5BA
    private let rowEven      = UIColor(red: 0.97, green: 0.97, blue: 0.97, alpha: 1)
    private let rowOdd       = UIColor.white
    private let textDark     = UIColor(red: 0.13, green: 0.13, blue: 0.13, alpha: 1)
    private let textGray     = UIColor(red: 0.50, green: 0.50, blue: 0.50, alpha: 1)

    // MARK: - Fonts

    private let titleFont    = UIFont.systemFont(ofSize: 22, weight: .bold)
    private let headingFont  = UIFont.systemFont(ofSize: 14, weight: .semibold)
    private let bodyFont     = UIFont.systemFont(ofSize: 11, weight: .regular)
    private let captionFont  = UIFont.systemFont(ofSize: 9,  weight: .regular)
    private let tableFont    = UIFont.systemFont(ofSize: 10, weight: .regular)
    private let tableBoldFont = UIFont.systemFont(ofSize: 10, weight: .semibold)

    // MARK: - Date Formatter

    private let dateFormatter: DateFormatter = {
        let f = DateFormatter()
        f.dateStyle = .medium
        f.timeStyle = .none
        return f
    }()

    // MARK: - CyclePredictionService

    private let predictor: CyclePredictorProtocol = CyclePredictionService()

    // MARK: - PDFGeneratorServiceProtocol

    func generateCycleSummaryPDF(cycles: [CycleEntry], logs: [DailyLog]) -> Data {
        let format = UIGraphicsPDFRendererFormat()
        let pageRect = CGRect(x: 0, y: 0, width: pageWidth, height: pageHeight)
        let renderer = UIGraphicsPDFRenderer(bounds: pageRect, format: format)

        return renderer.pdfData { ctx in
            ctx.beginPage()
            var cursor: CGFloat = marginV

            // Header
            cursor = drawHeader(title: "Cycle Summary Report", subtitle: "BloomHer Menstrual Health", cursor: cursor)

            // Generation date
            let genLine = "Generated: \(dateFormatter.string(from: Date()))"
            cursor = drawCaption(genLine, cursor: cursor)
            cursor += 12

            // Cycle table
            let sorted = cycles.sorted { $0.startDate < $1.startDate }
            cursor = drawSectionHeading("Cycle History (\(sorted.count) cycles recorded)", cursor: cursor)
            cursor = drawCycleTable(cycles: sorted, cursor: cursor, ctx: ctx, pageRect: pageRect)

            // Symptom summary
            if !logs.isEmpty {
                cursor += 16
                if cursor > pageHeight - marginV - 120 {
                    ctx.beginPage()
                    cursor = marginV
                }
                cursor = drawSectionHeading("Symptom & Mood Overview", cursor: cursor)
                cursor = drawSymptomSummary(logs: logs, cursor: cursor, ctx: ctx, pageRect: pageRect)
            }

            // Footer on all pages
            drawFooter(in: pageRect)
            drawWatermark(in: pageRect)
        }
    }

    func generatePregnancySummaryPDF(pregnancy: PregnancyProfile) -> Data {
        let format = UIGraphicsPDFRendererFormat()
        let pageRect = CGRect(x: 0, y: 0, width: pageWidth, height: pageHeight)
        let renderer = UIGraphicsPDFRenderer(bounds: pageRect, format: format)

        return renderer.pdfData { ctx in
            ctx.beginPage()
            var cursor: CGFloat = marginV

            // Header
            cursor = drawHeader(title: "Pregnancy Progress Report", subtitle: "BloomHer Pregnancy Tracker", cursor: cursor)

            // Overview card
            cursor = drawSectionHeading("Pregnancy Overview", cursor: cursor)
            cursor = drawPregnancyOverview(pregnancy: pregnancy, cursor: cursor)

            // Weight entries
            let weights = pregnancy.weightEntries.sorted { $0.date < $1.date }
            if !weights.isEmpty {
                cursor += 12
                cursor = drawSectionHeading("Weight Tracker", cursor: cursor)
                cursor = drawWeightTable(entries: weights, cursor: cursor, ctx: ctx, pageRect: pageRect)
            }

            // Appointments
            let appointments = pregnancy.appointments.sorted { $0.date < $1.date }
            if !appointments.isEmpty {
                cursor += 12
                if cursor > pageHeight - marginV - 120 {
                    ctx.beginPage()
                    cursor = marginV
                }
                cursor = drawSectionHeading("Appointments", cursor: cursor)
                cursor = drawAppointmentsTable(appointments: appointments, cursor: cursor, ctx: ctx, pageRect: pageRect)
            }

            drawFooter(in: pageRect)
            drawWatermark(in: pageRect)
        }
    }

    // MARK: - Drawing Primitives

    @discardableResult
    private func drawHeader(title: String, subtitle: String, cursor: CGFloat) -> CGFloat {
        var y = cursor

        // Accent bar
        let barRect = CGRect(x: marginH, y: y, width: contentWidth, height: 4)
        brandPink.setFill()
        UIBezierPath(roundedRect: barRect, cornerRadius: 2).fill()
        y += 12

        // Title
        let titleAttrs: [NSAttributedString.Key: Any] = [
            .font: titleFont,
            .foregroundColor: textDark
        ]
        let titleStr = NSAttributedString(string: title, attributes: titleAttrs)
        titleStr.draw(at: CGPoint(x: marginH, y: y))
        y += 28

        // Subtitle
        let subAttrs: [NSAttributedString.Key: Any] = [
            .font: bodyFont,
            .foregroundColor: textGray
        ]
        let subStr = NSAttributedString(string: subtitle, attributes: subAttrs)
        subStr.draw(at: CGPoint(x: marginH, y: y))
        y += 18

        // Divider
        let lineRect = CGRect(x: marginH, y: y, width: contentWidth, height: 0.5)
        UIColor.systemGray4.setFill()
        UIBezierPath(rect: lineRect).fill()
        y += 12

        return y
    }

    @discardableResult
    private func drawSectionHeading(_ text: String, cursor: CGFloat) -> CGFloat {
        let attrs: [NSAttributedString.Key: Any] = [
            .font: headingFont,
            .foregroundColor: brandPink
        ]
        NSAttributedString(string: text, attributes: attrs).draw(at: CGPoint(x: marginH, y: cursor))
        return cursor + 20
    }

    @discardableResult
    private func drawCaption(_ text: String, cursor: CGFloat) -> CGFloat {
        let attrs: [NSAttributedString.Key: Any] = [
            .font: captionFont,
            .foregroundColor: textGray
        ]
        NSAttributedString(string: text, attributes: attrs).draw(at: CGPoint(x: marginH, y: cursor))
        return cursor + 14
    }

    // MARK: - Cycle Table

    @discardableResult
    private func drawCycleTable(
        cycles: [CycleEntry],
        cursor: CGFloat,
        ctx: UIGraphicsPDFRendererContext,
        pageRect: CGRect
    ) -> CGFloat {
        let columns: [(header: String, width: CGFloat)] = [
            ("Start Date", 120),
            ("End Date", 120),
            ("Cycle Length", 100),
            ("Confirmed", 80)
        ]

        var y = cursor
        let rowHeight: CGFloat = 20

        // Table header row
        y = drawTableRow(
            columns:   columns.map { $0.header },
            widths:    columns.map { $0.width },
            y:         y,
            background: UIColor(red: 0.91, green: 0.55, blue: 0.61, alpha: 0.15),
            font:      tableBoldFont,
            textColor: textDark,
            rowHeight: rowHeight
        )

        // Data rows
        for (index, cycle) in cycles.enumerated() {
            // Page break if needed
            if y + rowHeight > pageHeight - marginV - 60 {
                drawFooter(in: pageRect)
                drawWatermark(in: pageRect)
                ctx.beginPage()
                y = marginV
                // Re-draw column headers after page break
                y = drawTableRow(
                    columns:   columns.map { $0.header },
                    widths:    columns.map { $0.width },
                    y:         y,
                    background: UIColor(red: 0.91, green: 0.55, blue: 0.61, alpha: 0.15),
                    font:      tableBoldFont,
                    textColor: textDark,
                    rowHeight: rowHeight
                )
            }

            let lengthText: String
            if let length = cycle.cycleLengthDays {
                lengthText = "\(length) days"
            } else if let end = cycle.endDate {
                let days = Calendar.current.dateComponents(
                    [.day],
                    from: Calendar.current.startOfDay(for: cycle.startDate),
                    to:   Calendar.current.startOfDay(for: end)
                ).day ?? 0
                lengthText = "\(days) days"
            } else {
                lengthText = "–"
            }

            let values = [
                dateFormatter.string(from: cycle.startDate),
                cycle.endDate.map { dateFormatter.string(from: $0) } ?? "–",
                lengthText,
                cycle.isConfirmed ? "Yes" : "No"
            ]

            y = drawTableRow(
                columns:   values,
                widths:    columns.map { $0.width },
                y:         y,
                background: index.isMultiple(of: 2) ? rowEven : rowOdd,
                font:      tableFont,
                textColor: textDark,
                rowHeight: rowHeight
            )
        }

        return y
    }

    // MARK: - Symptom Summary

    @discardableResult
    private func drawSymptomSummary(
        logs: [DailyLog],
        cursor: CGFloat,
        ctx: UIGraphicsPDFRendererContext,
        pageRect: CGRect
    ) -> CGFloat {
        var y = cursor

        // Aggregate mood counts
        var moodCounts: [String: Int] = [:]
        var symptomCounts: [String: Int] = [:]

        for log in logs {
            for mood in log.moods {
                moodCounts[mood.displayName, default: 0] += 1
            }
            for symptom in log.symptoms {
                symptomCounts[symptom.displayName, default: 0] += 1
            }
        }

        let columns: [(header: String, width: CGFloat)] = [
            ("Mood / Symptom", 200),
            ("Times Logged", 100)
        ]

        let rowHeight: CGFloat = 18

        // Top moods
        let topMoods = moodCounts.sorted { $0.value > $1.value }.prefix(10)
        if !topMoods.isEmpty {
            y = drawCaption("Top moods logged across \(logs.count) days", cursor: y)
            y = drawTableRow(
                columns:   columns.map { $0.header },
                widths:    columns.map { $0.width },
                y:         y,
                background: brandMint.withAlphaComponent(0.2),
                font:      tableBoldFont,
                textColor: textDark,
                rowHeight: rowHeight
            )
            for (index, entry) in topMoods.enumerated() {
                y = drawTableRow(
                    columns:   [entry.key, "\(entry.value)"],
                    widths:    columns.map { $0.width },
                    y:         y,
                    background: index.isMultiple(of: 2) ? rowEven : rowOdd,
                    font:      tableFont,
                    textColor: textDark,
                    rowHeight: rowHeight
                )
            }
        }

        return y + 8
    }

    // MARK: - Pregnancy Overview

    @discardableResult
    private func drawPregnancyOverview(pregnancy: PregnancyProfile, cursor: CGFloat) -> CGFloat {
        var y = cursor
        let rowHeight: CGFloat = 20
        let labelWidth: CGFloat = 180
        let valueWidth: CGFloat = contentWidth - labelWidth

        let rows: [(label: String, value: String)] = [
            ("Last Menstrual Period",  dateFormatter.string(from: pregnancy.lmpDate)),
            ("Due Date",               dateFormatter.string(from: pregnancy.dueDate)),
            ("Current Week",           "Week \(pregnancy.currentWeek)"),
            ("Trimester",              "Trimester \(pregnancy.trimester)"),
            ("Days Until Due",         "\(pregnancy.daysUntilDue) days"),
            ("Baby Name",              pregnancy.babyName ?? "–"),
        ]

        for (index, row) in rows.enumerated() {
            let bg = index.isMultiple(of: 2) ? rowEven : rowOdd
            y = drawTableRow(
                columns:   [row.label, row.value],
                widths:    [labelWidth, valueWidth],
                y:         y,
                background: bg,
                font:      tableFont,
                textColor: textDark,
                rowHeight: rowHeight
            )
        }

        return y
    }

    // MARK: - Weight Table

    @discardableResult
    private func drawWeightTable(
        entries: [WeightEntry],
        cursor: CGFloat,
        ctx: UIGraphicsPDFRendererContext,
        pageRect: CGRect
    ) -> CGFloat {
        let columns: [(header: String, width: CGFloat)] = [
            ("Date", 160),
            ("Weight (kg)", 120)
        ]

        var y = cursor
        let rowHeight: CGFloat = 18

        y = drawTableRow(
            columns:   columns.map { $0.header },
            widths:    columns.map { $0.width },
            y:         y,
            background: brandMint.withAlphaComponent(0.2),
            font:      tableBoldFont,
            textColor: textDark,
            rowHeight: rowHeight
        )

        for (index, entry) in entries.enumerated() {
            if y + rowHeight > pageHeight - marginV - 60 {
                drawFooter(in: pageRect)
                drawWatermark(in: pageRect)
                ctx.beginPage()
                y = marginV
            }
            y = drawTableRow(
                columns:   [dateFormatter.string(from: entry.date), String(format: "%.1f kg", entry.weightKg)],
                widths:    columns.map { $0.width },
                y:         y,
                background: index.isMultiple(of: 2) ? rowEven : rowOdd,
                font:      tableFont,
                textColor: textDark,
                rowHeight: rowHeight
            )
        }
        return y
    }

    // MARK: - Appointments Table

    @discardableResult
    private func drawAppointmentsTable(
        appointments: [Appointment],
        cursor: CGFloat,
        ctx: UIGraphicsPDFRendererContext,
        pageRect: CGRect
    ) -> CGFloat {
        let columns: [(header: String, width: CGFloat)] = [
            ("Title", 200),
            ("Date", 140),
            ("Completed", 80)
        ]

        var y = cursor
        let rowHeight: CGFloat = 18

        y = drawTableRow(
            columns:   columns.map { $0.header },
            widths:    columns.map { $0.width },
            y:         y,
            background: brandMint.withAlphaComponent(0.2),
            font:      tableBoldFont,
            textColor: textDark,
            rowHeight: rowHeight
        )

        for (index, appt) in appointments.enumerated() {
            if y + rowHeight > pageHeight - marginV - 60 {
                drawFooter(in: pageRect)
                drawWatermark(in: pageRect)
                ctx.beginPage()
                y = marginV
            }
            y = drawTableRow(
                columns: [appt.title, dateFormatter.string(from: appt.date), appt.isCompleted ? "Yes" : "No"],
                widths:  columns.map { $0.width },
                y:       y,
                background: index.isMultiple(of: 2) ? rowEven : rowOdd,
                font:    tableFont,
                textColor: textDark,
                rowHeight: rowHeight
            )
        }
        return y
    }

    // MARK: - Generic Table Row

    @discardableResult
    private func drawTableRow(
        columns: [String],
        widths: [CGFloat],
        y: CGFloat,
        background: UIColor,
        font: UIFont,
        textColor: UIColor,
        rowHeight: CGFloat
    ) -> CGFloat {
        var x = marginH
        let totalWidth = widths.reduce(0, +)
        let rowRect = CGRect(x: x, y: y, width: min(totalWidth, contentWidth), height: rowHeight)

        background.setFill()
        UIBezierPath(rect: rowRect).fill()

        let attrs: [NSAttributedString.Key: Any] = [
            .font: font,
            .foregroundColor: textColor
        ]

        for (index, column) in columns.enumerated() {
            guard index < widths.count else { break }
            let cellRect = CGRect(x: x + 4, y: y + 4, width: widths[index] - 8, height: rowHeight - 8)
            let str = NSAttributedString(string: column, attributes: attrs)
            str.draw(in: cellRect)
            x += widths[index]
        }

        // Bottom border
        UIColor.systemGray5.setStroke()
        let path = UIBezierPath()
        path.move(to:    CGPoint(x: marginH, y: y + rowHeight))
        path.addLine(to: CGPoint(x: marginH + min(totalWidth, contentWidth), y: y + rowHeight))
        path.lineWidth = 0.5
        path.stroke()

        return y + rowHeight
    }

    // MARK: - Footer

    private func drawFooter(in pageRect: CGRect) {
        let footerY = pageHeight - marginV + 4
        let disclaimer = "DISCLAIMER: This document is generated by BloomHer for personal reference only. It does not constitute medical advice. Please consult a qualified healthcare provider for any medical concerns."
        let attrs: [NSAttributedString.Key: Any] = [
            .font: captionFont,
            .foregroundColor: textGray
        ]
        let rect = CGRect(x: marginH, y: footerY, width: contentWidth, height: 28)
        NSAttributedString(string: disclaimer, attributes: attrs).draw(in: rect)
    }

    private func drawWatermark(in pageRect: CGRect) {
        let watermarkY = pageHeight - marginV - 4
        let text = "Generated by BloomHer  •  \(dateFormatter.string(from: Date()))"
        let attrs: [NSAttributedString.Key: Any] = [
            .font: captionFont,
            .foregroundColor: brandPink.withAlphaComponent(0.5)
        ]
        let size = NSAttributedString(string: text, attributes: attrs).size()
        let x    = pageWidth - marginH - size.width
        NSAttributedString(string: text, attributes: attrs).draw(at: CGPoint(x: x, y: watermarkY))
    }
}
